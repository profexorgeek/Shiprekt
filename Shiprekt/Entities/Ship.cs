using System;
using System.Collections.Generic;
using System.Text;
using FlatRedBall;
using FlatRedBall.Input;
using FlatRedBall.Instructions;
using FlatRedBall.AI.Pathfinding;
using FlatRedBall.Graphics.Animation;
using FlatRedBall.Graphics.Particle;
using FlatRedBall.Math.Geometry;
using Microsoft.Xna.Framework;
using static Shiprekt.Entities.ShipSail;
using FlatRedBall.Debugging;

namespace Shiprekt.Entities
{
	public partial class Ship
	{
        #region Fields/Properties

        public bool AllowedToDrive
		{
			get
			{
				return IsAllowedToDrive;
			}
			set
			{
				IsAllowedToDrive = value;
			}
		}
		public int TeamIndex { get; private set; }

		IPressableInput shootLeftInput;
		IPressableInput shootRightInput;
		I1DInput sailTurningInput;

        DataTypes.RacingEntityValues EffectiveRacingEntityValues;
        DataTypes.RacingEntityValues BaseRacingEntityValues;

        #endregion

        #region Initialize

        /// <summary>
        /// Initialization logic which is execute only one time for this Entity (unless the Entity is pooled).
        /// This method is called when the Entity is added to managers. Entities which are instantiated but not
        /// added to managers will not have this method called.
        /// </summary>
        private void CustomInitialize()
        {
            this.ForwardDirection = RacingDirection.Right;

            InitializeMovementValues();

            Health = ShipEntityValuesInstance.MaxHealth;

#if DEBUG
            DoDebugInitialize();
#endif
        }

        private void DoDebugInitialize()
        {
            if(DebuggingVariables.ShowShipCollisions)
            {
                this.Collision.Visible = true;
            }
        }

        internal void SetSail(SailColor sailColor)
        {
            ShipSailInstance.CurrentSailColorState = sailColor;
        }

        private void InitializeMovementValues()
        {
            // Store off the base values, which are the values unmodified from the CSV. If the CSV reloads, this will get updated
            BaseRacingEntityValues = CarData;

            // Copy the values and store them in an "Effective" variable. Since this is a clone, these values
            // can be modified without changing the base CarData (or anything from the CSV). These values will
            // get modified at runtime according to wind and any other gameplay mechanics we want to add
            EffectiveRacingEntityValues = FlatRedBall.IO.FileManager.CloneObject(CarData);

            // Tell the game to use the effective values as its current values.
            CarData = EffectiveRacingEntityValues;
        }

        partial void CustomInitializeTopDownInput()
		{
			if (InputDevice is Xbox360GamePad gamePad)
			{
				shootLeftInput = gamePad.LeftTrigger
					.Or(gamePad.GetButton(Xbox360GamePad.Button.LeftShoulder));
				shootRightInput = gamePad.RightTrigger
					.Or(gamePad.GetButton(Xbox360GamePad.Button.RightShoulder));
				sailTurningInput = gamePad.RightStick.Horizontal;
				IPressableInput gas = gamePad.GetButton(Xbox360GamePad.Button.B);
				Gas = new DelegateBasedPressableInput(() => !gas.IsDown, () => gas.WasJustReleased, () => gas.WasJustPressed).To1DInput();
			}
			else if (InputDevice is Keyboard keyboard)
			{
				shootLeftInput = keyboard.GetKey(Microsoft.Xna.Framework.Input.Keys.Q)
					.Or(InputManager.Mouse.GetButton(Mouse.MouseButtons.LeftButton));

				shootRightInput = keyboard.GetKey(Microsoft.Xna.Framework.Input.Keys.E)
					.Or(InputManager.Mouse.GetButton(Mouse.MouseButtons.RightButton));
				sailTurningInput = InputManager.Keyboard.Get1DInput(Microsoft.Xna.Framework.Input.Keys.Right, Microsoft.Xna.Framework.Input.Keys.Left);
				IPressableInput gas = InputManager.Keyboard.GetKey(Microsoft.Xna.Framework.Input.Keys.Space);
				Gas = new DelegateBasedPressableInput(() => !gas.IsDown, () => gas.WasJustReleased, () => gas.WasJustPressed).To1DInput();
			}
		}

		public void SetTeam(int teamIndex)
		{
			TeamIndex = teamIndex;

		}

        #endregion

        #region Activity

        private void CustomActivity()
		{
			DoShootingActivity();

			DoSailTurningActivity();

			//Drag generated by the ship in the water. Applies whenever there is movement of any sort. 
			//if (Velocity != Vector3.Zero && Velocity.Length() > ShipEntityValuesInstance.MinSpeed)
			//	ApplyFriction(ShipEntityValuesInstance.ShipDrag);

            DoDebugActivity();

            DoWakeSpeed();
		}

        private void DoDebugActivity()
        {
            if(Entities.DebuggingVariables.IsShipMovementInfoDisplayed)
            {
                string debugString = $@"Velocity: {Velocity}
    EffectiveForwardAcceleration: {EffectiveRacingEntityValues.ForwardAcceleration},
    MaxSpeed: {EffectiveRacingEntityValues.EffectiveMaxSpeed}";

                FlatRedBall.Debugging.Debugger.Write(debugString);
            }
        }

        private void DoShootingActivity()
		{
			if (shootLeftInput.WasJustPressed)
			{
				Shoot(this.Left.ToVector2());
			}
			else if (shootRightInput.WasJustPressed)
			{
				Shoot(this.Right.ToVector2());

			}
		}

		private void DoSailTurningActivity()
		{
			var turnSpeed = sailTurningInput.Value * ShipEntityValuesInstance.SailRotationSpeed;
			var left = ShipEntityValuesInstance.MaxSailRotation * ((float)Math.PI / 180);
			var right = 360 * ((float)Math.PI / 180) - ShipEntityValuesInstance.MaxSailRotation * ((float)Math.PI / 180);
			var middle = (float)Math.PI;

			var maxLeftTurningRight = ShipSailInstance.RelativeRotationZ == left && turnSpeed < 0;
			var maxRightTurningLeft = ShipSailInstance.RelativeRotationZ == right && turnSpeed > 0;
			var safeZone = ShipSailInstance.RelativeRotationZ < left || ShipSailInstance.RelativeRotationZ > right;
			if (maxLeftTurningRight || maxRightTurningLeft || safeZone)
			{
				ShipSailInstance.RelativeRotationZVelocity = turnSpeed;
			}
			else
			{
				if (ShipSailInstance.RelativeRotationZ > left && ShipSailInstance.RelativeRotationZ < middle)
				{
					ShipSailInstance.RelativeRotationZ = left;
				}
				else if (ShipSailInstance.RelativeRotationZ < right && ShipSailInstance.RelativeRotationZ > middle)
				{
					ShipSailInstance.RelativeRotationZ = right;
				}
				ShipSailInstance.RelativeRotationZVelocity = 0;
			}
		}

        void DoWakeSpeed()
        {
            var currentSpeed = Velocity.Length();
            var maxSpeed = BaseRacingEntityValues.EffectiveMaxSpeed;
            var speedPercent = currentSpeed / maxSpeed;
            WakeEffectInstance.EffectStrength = speedPercent;

            //FlatRedBall.Debugging.Debugger.CommandLineWrite(speedPercent);
        }

		internal void Shoot(Vector2 bulletDirection)
		{
			var bullet = Factories.BulletFactory.CreateNew(this.X, this.Y);

			bullet.Velocity = (bulletDirection * Bullet.BulletSpeed).ToVector3();
			bullet.TeamIndex = this.TeamIndex;
			var bulletDuration = Bullet.BulletDistance / Bullet.BulletSpeed;

			bullet.Call(bullet.HitSurface).After(bulletDuration);
		}

		internal void TakeDamage(int damageAmount)
		{
			Health -= damageAmount;
			if (Health <= 0) Die();
		}

		public void ApplyWind(Vector2 windDirectionNormalized)
		{           
            // Update the max speed according to the wind          
            var sailToWindDot = Vector2.Dot(ShipSailInstance.RotationMatrix.Right.ToVector2(), windDirectionNormalized);
            var coefficient = sailToWindDot == 0 ? 0 : (sailToWindDot /= 2) + .5f;

#if DEBUG
            if(DebuggingVariables.FastMovement)
            {
                EffectiveRacingEntityValues.EffectiveMaxSpeed = BaseRacingEntityValues.EffectiveMaxSpeed;
            }
            else
#endif
            {
              EffectiveRacingEntityValues.EffectiveMaxSpeed = Math.Max(MinSpeed, BaseRacingEntityValues.EffectiveMaxSpeed * coefficient); 
            }

			//Change the sail visual. 
			ShipSailInstance.UpdateSailVisual(windDirectionNormalized);
		}

        #endregion

        #region Destroy

        private void CustomDestroy()
		{


		}

		internal void Die()
		{
			Destroy();
		}

        #endregion

        private static void CustomLoadStaticContent(string contentManagerName)
		{


		}

	}

    #region Extension Methods

    public static class Vector3Extensions
	{
		public static Vector3 Normalized(this Vector3 sender)
		{
			Vector3 normalized = sender;
			normalized.Normalize();
			return normalized; 
		}
	}

	public static class Vector2Extensions
	{
		public static Vector2 Normalized(this Vector2 sender)
		{
			Vector2 normalized = sender;
			normalized.Normalize();
			return normalized;
		}
	}

    #endregion
}
