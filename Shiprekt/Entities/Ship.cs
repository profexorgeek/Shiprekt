using System;
using System.Collections.Generic;
using System.Text;
using FlatRedBall;
using FlatRedBall.Input;
using FlatRedBall.Instructions;
using FlatRedBall.AI.Pathfinding;
using FlatRedBall.Graphics.Animation;
using FlatRedBall.Graphics.Particle;
using FlatRedBall.Math.Geometry;
using Microsoft.Xna.Framework;
using static Shiprekt.Entities.ShipSail;

namespace Shiprekt.Entities
{
	public partial class Ship
	{
        #region Fields/Properties

        public bool AllowedToDrive
		{
			get
			{
				return IsAllowedToDrive;
			}
			set
			{
				IsAllowedToDrive = value;
			}
		}
		public int TeamIndex { get; private set; }

		IPressableInput shootLeftInput;
		IPressableInput shootRightInput;
		I1DInput sailTurningInput;

        DataTypes.RacingEntityValues EffectiveRacingEntityValues;
        DataTypes.RacingEntityValues BaseRacingEntityValues;

        #endregion

        #region Initialize

        /// <summary>
        /// Initialization logic which is execute only one time for this Entity (unless the Entity is pooled).
        /// This method is called when the Entity is added to managers. Entities which are instantiated but not
        /// added to managers will not have this method called.
        /// </summary>
        private void CustomInitialize()
        {
            this.ForwardDirection = RacingDirection.Right;

            InitializeMovementValues();

            Health = ShipEntityValuesInstance.MaxHealth;
        }

        private void InitializeMovementValues()
        {
            // Store off the base values, which are the values unmodified from the CSV. If the CSV reloads, this will get updated
            BaseRacingEntityValues = CarData;

            // Copy the values and store them in an "Effective" variable. Since this is a clone, these values
            // can be modified without changing the base CarData (or anything from the CSV). These values will
            // get modified at runtime according to wind and any other gameplay mechanics we want to add
            EffectiveRacingEntityValues = FlatRedBall.IO.FileManager.CloneObject(CarData);

            // Tell the game to use the effective values as its current values.
            CarData = EffectiveRacingEntityValues;
        }

        partial void CustomInitializeTopDownInput()
		{
			if (InputDevice is Xbox360GamePad gamePad)
			{
				shootLeftInput = gamePad.LeftTrigger
					.Or(gamePad.GetButton(Xbox360GamePad.Button.LeftShoulder));
				shootRightInput = gamePad.RightTrigger
					.Or(gamePad.GetButton(Xbox360GamePad.Button.RightShoulder));
				sailTurningInput = gamePad.RightStick.Horizontal;
				IPressableInput gas = gamePad.GetButton(Xbox360GamePad.Button.B);
				Gas = new DelegateBasedPressableInput(() => !gas.IsDown, () => gas.WasJustReleased, () => gas.WasJustPressed).To1DInput();
			}
			else if (InputDevice is Keyboard keyboard)
			{
				shootLeftInput = keyboard.GetKey(Microsoft.Xna.Framework.Input.Keys.Q)
					.Or(InputManager.Mouse.GetButton(Mouse.MouseButtons.LeftButton));

				shootRightInput = keyboard.GetKey(Microsoft.Xna.Framework.Input.Keys.E)
					.Or(InputManager.Mouse.GetButton(Mouse.MouseButtons.RightButton));
				sailTurningInput = InputManager.Keyboard.Get1DInput(Microsoft.Xna.Framework.Input.Keys.Right, Microsoft.Xna.Framework.Input.Keys.Left);
				IPressableInput gas = InputManager.Keyboard.GetKey(Microsoft.Xna.Framework.Input.Keys.Space);
				Gas = new DelegateBasedPressableInput(() => !gas.IsDown, () => gas.WasJustReleased, () => gas.WasJustPressed).To1DInput();
			}
		}

		public void SetTeam(int teamIndex)
		{
			TeamIndex = teamIndex;
			switch (teamIndex)
			{
				case 0:
					ShipSailInstance.CurrentSailColorState = SailColor.Green;
					break;
				case 1:
					ShipSailInstance.CurrentSailColorState = SailColor.Pink;
					break;
				case 2:
					ShipSailInstance.CurrentSailColorState = SailColor.RedStripe;
					break;
				default:
					ShipSailInstance.CurrentSailColorState = SailColor.Black;
					break;
			}
		}

        #endregion

        #region Activity

        private void CustomActivity()
		{
			DoShootingActivity();

			DoSailTurningActivity();

			//Drag generated by the ship in the water. Applies whenever there is movement of any sort. 
			//if (Velocity != Vector3.Zero && Velocity.Length() > ShipEntityValuesInstance.MinSpeed)
			//	ApplyFriction(ShipEntityValuesInstance.ShipDrag);

            DoDebugActivity();
		}

        private void DoDebugActivity()
        {
            if(Entities.DebuggingVariables.IsShipMovementInfoDisplayed)
            {
                string debugString = $@"Velocity: {Velocity}
    EffectiveForwardAcceleration: {EffectiveRacingEntityValues.ForwardAcceleration},
    MaxSpeed: {EffectiveRacingEntityValues.EffectiveMaxSpeed}";

                FlatRedBall.Debugging.Debugger.Write(debugString);
            }
        }

        private void DoShootingActivity()
		{
			if (shootLeftInput.WasJustPressed)
			{
				Shoot(this.Left.ToVector2());
			}
			else if (shootRightInput.WasJustPressed)
			{
				Shoot(this.Right.ToVector2());

			}
		}

		private void DoSailTurningActivity()
		{
			var turnSpeed = sailTurningInput.Value * ShipEntityValuesInstance.SailRotationSpeed;
			var left = ShipEntityValuesInstance.MaxSailRotation * ((float)Math.PI / 180);
			var right = 360 * ((float)Math.PI / 180) - ShipEntityValuesInstance.MaxSailRotation * ((float)Math.PI / 180);
			var middle = (float)Math.PI;

			var maxLeftTurningRight = ShipSailInstance.RelativeRotationZ == left && turnSpeed < 0;
			var maxRightTurningLeft = ShipSailInstance.RelativeRotationZ == right && turnSpeed > 0;
			var safeZone = ShipSailInstance.RelativeRotationZ < left || ShipSailInstance.RelativeRotationZ > right;
			if (maxLeftTurningRight || maxRightTurningLeft || safeZone)
			{
				ShipSailInstance.RelativeRotationZVelocity = turnSpeed;
			}
			else
			{
				if (ShipSailInstance.RelativeRotationZ > left && ShipSailInstance.RelativeRotationZ < middle)
				{
					ShipSailInstance.RelativeRotationZ = left;
				}
				else if (ShipSailInstance.RelativeRotationZ < right && ShipSailInstance.RelativeRotationZ > middle)
				{
					ShipSailInstance.RelativeRotationZ = right;
				}
				ShipSailInstance.RelativeRotationZVelocity = 0;
			}
		}

		internal void Shoot(Vector2 bulletDirection)
		{
			var bullet = Factories.BulletFactory.CreateNew(this.X, this.Y);

			bullet.Velocity = (bulletDirection * Bullet.BulletSpeed).ToVector3();
			bullet.TeamIndex = this.TeamIndex;
			var bulletDuration = Bullet.BulletDistance / Bullet.BulletSpeed;

			bullet.Call(bullet.HitSurface).After(bulletDuration);
		}

		internal void TakeDamage(int damageAmount)
		{
			Health -= damageAmount;
			if (Health <= 0) Die();
		}

		public void ApplyWind(Vector2 windDirectionNormalized)
		{
            // Update the max speed according to the wind
            var shipToWindDot = Vector2.Dot(this.RotationMatrix.Up.ToVector2(), windDirectionNormalized);
            if(shipToWindDot > 0)
            {
                // tailwind
                EffectiveRacingEntityValues.EffectiveMaxSpeed = BaseRacingEntityValues.EffectiveMaxSpeed + shipToWindDot * TailwindSpeedIncrease;
            }
            else
            {
                // headwind - dot will be neagive here so can add
                EffectiveRacingEntityValues.EffectiveMaxSpeed = BaseRacingEntityValues.EffectiveMaxSpeed + shipToWindDot * HeadwindSpeedDecrease;
            }


            var sailToWindDot = Vector2.Dot(this.ShipSailInstance.RotationMatrix.Up.ToVector2(), windDirectionNormalized);
            // The sail should only impact speed if it is catching the wind. If it's the opposite, don't slow the ship down..unless that's the intended design?
            EffectiveRacingEntityValues.ForwardAcceleration = BaseRacingEntityValues.ForwardAcceleration;
            if(sailToWindDot > 0)
            {
                EffectiveRacingEntityValues.ForwardAcceleration += sailToWindDot * MaxSailAccelerationBoost;
            }

			//Change the sail visual. 
			ShipSailInstance.UpdateSailVisual(windDirectionNormalized);
		}

		/// <summary>
		/// Friction is a force that will slow down movement, but will not speed up movement. 
		/// </summary>
		/// <param name="friction"></param>
		public void ApplyFriction(float magnitude)
		{
			Vector2 normal = Velocity.Normalized().ToVector2(); 
			var drag = normal * magnitude * TimeManager.SecondDifference;
			var dragMag = drag.Length();
			var velMag = Velocity.Length();
			if (velMag - dragMag < 0) Velocity = Vector3.Zero;
			else Velocity -= drag.ToVector3();
		}

		/// <summary>
		/// Force is applied to velocity even if the ship is not moving. 
		/// </summary>
		/// <param name="normal"></param>
		/// <param name="magnitude"></param>
		public void ApplyForce(Vector2 normal, float magnitude)
		{
			var force = normal * magnitude * TimeManager.SecondDifference;
			Velocity += force.ToVector3(); 
		}

        #endregion

        #region Destroy

        private void CustomDestroy()
		{


		}

		internal void Die()
		{
			Destroy();
		}

        #endregion

        private static void CustomLoadStaticContent(string contentManagerName)
		{


		}

	}

    #region Extension Methods

    public static class Vector3Extensions
	{
		public static Vector3 Normalized(this Vector3 sender)
		{
			Vector3 normalized = sender;
			normalized.Normalize();
			return normalized; 
		}
	}

	public static class Vector2Extensions
	{
		public static Vector2 Normalized(this Vector2 sender)
		{
			Vector2 normalized = sender;
			normalized.Normalize();
			return normalized;
		}
	}

    #endregion
}
